#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author: 'arvin'

import re
from collections import namedtuple
import requests
import time

import utils
from exceptions import BadHostInfoException, RequetsHostException
from prettytable import PrettyTable

ExploitTarget = namedtuple('e_target', ['host', 'port', 'brand', 'alternative_exploit', 'affective_exploit'])


class BaseExploit(object):
    __info__ = {
        'name': '',
        'description': '',
        'reference': [],
    }
    prompt = ''
    exploit_log_name = './log/{}.txt'.format(time.strftime('%Y%m%d%H%M%S', time.localtime()))
    exploit_log_file = None

    def __init__(self):
        self.username = 'admin'
        self.password = 'admin'
        self.s = requests.Session()

    def input_to_continue(self, hint='Continue(Y/N):'):
        user_input = input(hint)
        if user_input.lower() == 'y' or user_input.lower() == 'yes':
            return True
        else:
            return False

    def set_credits(self):
        self.username = input('Username: ')
        self.password = input('Password: ')

    def run(self, host, port, timeout):
        pass

    def check(self, host, port, timeout):
        return False

    def command_loop(self, host, port, timeout):
        while True:
            cmd = input("cmd > ")
            if cmd in ['exit', 'quit']:
                return

            response = self.execute(host, port, timeout, cmd)
            utils.print_info(response)

    def execute(self, host, port, timeout, cmd):
        return ''

    def print_check_result(self, b, host):
        if b:
            utils.print_success('{} is affected by {}'.format(host, self.__info__['name']))
        else:
            utils.print_info('{} is not affected by {}'.format(host, self.__info__['name']))

    def print_requests_err(self, host, port, err):
        utils.print_warning(err)

    def http_get(self, s, url, timeout, **kwargs):
        try:
            r = s.get(url, timeout=timeout, verify=False, **kwargs)
        except requests.RequestException as err:
            host = utils.host_in_url(url)
            return None, RequetsHostException('{} request error, msg: {}'
                                              .format(host, type(err).__name__))
        else:
            return r, None

    def http_post(self, s, url, timeout, data, **kwargs):
        try:
            r = s.post(url, timeout=timeout, data=data, verify=False, **kwargs)
        except requests.RequestException as err:
            host = utils.host_in_url(url)
            return None, RequetsHostException('{} request error, msg: {}'
                                              .format(host, type(err).__name__))
        else:
            return r, None

    def regx_grab(self, text, reg, index=1):
        reg_match = re.compile(reg, re.S).search(text)
        if reg_match:
            if len(reg_match.groups()) >= index:
                return reg_match.group(index)

        return ''

    def m_log(self, host, port, info):
        if BaseExploit.exploit_log_file is None:
            try:
                BaseExploit.exploit_log_file = open(BaseExploit.exploit_log_name, 'w')
                utils.print_info('Host: {},{}:\n{}'.format(host, port, info), file=BaseExploit.exploit_log_file, flush=True)
            except Exception as e:
                utils.print_warning('Can not create log file')
        else:
            utils.print_info('Host: {},{}:\n{}'.format(host, port, info), file=BaseExploit.exploit_log_file, flush=True)


class ExploitTask(object):
    def __init__(self):
        self.__targets = []
        self.__timeout = 60
        self.__threads = 2
        self.__output = ''
        self.__current = 0

    def emptyhosts(self, *args):
        utils.print_warning('are you sure to clear all hosts? ')
        user_input = input('Y/N:')
        if user_input.lower() == 'y' or user_input.lower() == 'yes':
            self.__targets = []
            utils.print_info('clear all last results')

    def add(self, host_infos):
        total = 0
        for host_info in host_infos:
            try:
                host = host_info.split(':')[0].strip()
                if utils.valid_host(host) and (host not in self.__targets):
                    if len(host_info.split(':')) > 1:
                        port = host_info.split(':')[1]
                        if not utils.valid_port(port):
                            continue
                    else:
                        port = 80
                    self.__targets.append(ExploitTarget(host=host, port=port, brand=None,
                                                        alternative_exploit=None, affective_exploit=None))
                    total += 1
            except IndexError:
                pass

        utils.print_info('Total {} hosts added'.format(total))

    def timeout(self, timeouts):
        for t in timeouts:
            if utils.valid_timeout(t):
                self.__timeout = int(t)
                utils.print_info('set timeout: {}'.format(self.__timeout))
                return

        raise BadHostInfoException('bad timeout number. (t should between 1 - 15)')

    def file(self, paths):
        for path in paths:
            if path != '':
                if utils.valid_file_exist(path):
                    self.read_host_file(path)
                    break
                else:
                    raise BadHostInfoException('no such file: {}'.format(path))

    def output(self, paths):
        for path in paths:
            if path != '':
                if utils.valid_file_creatable(path):
                    self.__output = path
                    break
                else:
                    raise BadHostInfoException('cannot create output file: {}'.format(path))

    def next(self, args):
        if len(self.__targets) == 0:
            utils.print_failed('no targets list')
            return
        if self.__current < len(self.__targets) - 1:
            self.__current += 1
            utils.print_info(
                'move to ' + utils.Color.GREEN + str(self.__current) + utils.Color.ENDC + ': ' + self.__targets[
                    self.__current].host)
        else:
            utils.print_failed('targets list move to the end')

    def last(self, args):
        if len(self.__targets) == 0:
            utils.print_failed('no targets list')
            return
        if self.__current > 0:
            self.__current -= 1
            utils.print_info(
                'move to ' + utils.Color.GREEN + str(self.__current) + utils.Color.ENDC + ': ' + self.__targets[
                    self.__current].host)
        else:
            utils.print_failed('targets list move to the first')

    def threads(self, threads):
        for t in threads:
            if utils.valid_threads(threads):
                self.__threads = int(threads)
                return

        raise BadHostInfoException('bad threads number. (t should between 1 - 50')

    def show(self):
        utils.print_help('Target info:')
        i = 0
        x = PrettyTable()
        x.field_names = ['index', 'host', 'port', 'brand', 'alternative', 'affective']
        for target in self.__targets:
            # utils.print_info(' ' * 4 + utils.Color.GREEN + str(i) + ': ' + utils.Color.ENDC +
            #                  target.host + ':' + str(target.port) +
            #                  ', ' + utils.Color.GREEN + 'brand: ' + utils.Color.ENDC + (
            #                  'unknown' if not target.brand else target.brand) +
            #                  ', ' + utils.Color.GREEN + 'alternative exploit: ' + utils.Color.ENDC + (
            #                  '[]' if not target.alternative_exploit else str(target.alternative_exploit)) +
            #                  ', ' + utils.Color.GREEN + 'affective exploit: ' + utils.Color.ENDC +
            #                  '[]' if not target.affective_exploit else str(target.affective_exploit))
            x.add_row([i, target.host, target.port, target.brand, target.alternative_exploit, target.affective_exploit])
            i += 1
        utils.print_info(x)

        if self.get_current():
            utils.print_help('Current: ', end='')
            utils.print_info(str(self.get_current().host))
        utils.print_help('Threads: ', end='')
        utils.print_info(str(self.__threads))
        utils.print_help('Timeout: ', end='')
        utils.print_info(str(self.__timeout))
        utils.print_help('Output: ', end='')
        utils.print_info(None if not self.__output else self.__output)
        # utils.print_info("Target info: {}\n"
        #                  "Threads: {}\n"
        #                  "Timeout: {}\n"
        #                  "Output: {}"
        #                  .format(self.__targets, self.__threads, self.__timeout, self.__output))

    def get_targets(self):
        return self.__targets

    def get_threads(self):
        return self.__threads

    def get_timeout(self):
        return self.__timeout

    def get_output(self):
        return self.__output

    def get_current(self):
        if len(self.__targets) > 0:
            return self.__targets[self.__current]
        else:
            return None

    def set_current(self, current):
        self.__targets[self.__current] = current

    def read_host_file(self, path):
        fd = open(path, 'r')
        total = 0
        with_extra_reg = r"""
                        # 192.168.1.1
                        ((?:\d+\.){3}(?:\d+))
                        # : and space
                        (?:\s+)?:(?:\s+)?
                        # port
                        (\d+)
                        # , and space
                        (?:\s+)?,(?:\s+)?
                        # brand
                        ([^,]+(?<!\s))
                        # other
                        (?:\s+)?,(?:\s+)?(?:[^,]+)(?:\s+)?,(?:\s+)?(?:[^,]+|(?:\[(?:.+)?\]))(?:\s+)?,(?:\s+)?
                        # alternative exploit
                        \[(.+)?\]"""
        no_extra_reg = r"""
                        # 192.168.1.1
                        ((?:\d+\.){3}(?:\d+))
                        # : and space
                        (?:\s+)?:(?:\s+)?
                        # port
                        (\d+)
                        # , and space
                        (?:(?:\s+)?,(?:\s+)?
                        # brand and not end with blank
                        ([^,]+(?<!\s)))?"""
        with_extra_reg = re.compile(with_extra_reg, re.X)
        no_extra_reg = re.compile(no_extra_reg, re.X)
        for line in map(lambda x: x.strip(), fd.readlines()):
            match = with_extra_reg.search(line)
            host = None
            port = None
            brand = None
            alternative_exploit = None
            if match:
                host, port, brand, alternative_exploit = match.group(1), match.group(2), match.group(3), match.group(4)

            else:
                match = no_extra_reg.search(line)
                if match:
                    host, port, brand = match.group(1), match.group(2), match.group(3)

            if match:
                if utils.valid_host(host) and utils.valid_port(port):
                    if utils.valid_exploit(alternative_exploit):
                        target = ExploitTarget(host=host, port=port, brand=brand,
                                               alternative_exploit=alternative_exploit, affective_exploit=None)
                        if target not in self.__targets:
                            self.__targets.append(target)
                            total += 1
                    else:
                        target = ExploitTarget(host=host, port=port, brand=None,
                                               alternative_exploit=None, affective_exploit=None)
                        utils.print_warning('{} alternative hosts info error, sets to None'.format(host))
                        if target not in self.__targets:
                            self.__targets.append(target)
                            total += 1

        utils.print_info('Total {} hosts added'.format(total))
