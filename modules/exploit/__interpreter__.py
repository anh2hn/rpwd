#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author: 'arvin'
import inspect

import utils
from template.interpreter import BaseInterpreter
from template.exploit import ExploitTask, ExploitTarget
from exceptions import BadHostInfoException, ModuleImportException


class Interpreter(BaseInterpreter):
    def __init__(self):
        super(Interpreter, self).__init__()
        self.prompt_module = 'Exploit'
        self.module = None
        self.modules = utils.index_modules(modules_directory='/'.join((utils.MODULES_DIR, 'exploit/')))
        self.files = utils.list_files('./')
        self.sub_opt = {'task': ['add', 'next', 'last', 'timeout',
                                 'threads', 'file', 'output', 'emptyhosts'],
                        # 'show': ['hosts', 'current', 'output', 'all'],
                        }
        self.task = ExploitTask()
        self.cmdloop()

    def change_prompt(self, module):
        self.prompt_module = module.prompt
        self.generate_prompt()

    def do_load(self, scanner_name):
        module_path = utils.pythonize_path(scanner_name)
        module_path = '.'.join(('modules.exploit', module_path))
        try:
            self.module = utils.import_module(module_path, 'Exploit')()
        except ModuleImportException as err:
            utils.print_failed(err)
        else:
            self.change_prompt(self.module)

    def complete_load(self, text, line, *args, **kwargs):
        available_modules = [s for s in self.modules if s.startswith(text)]

        def split_modules(available_module):
            head, _, tail = available_module[len(text):].partition('.')
            if head:
                return text + head
            if not head and not tail:
                # indicates available_module[len(text)] is empty ''
                return
            else:
                # indicates available_module[len(text)] begins with '.'
                next_head, _, _ = tail.partition('.')
                return text + '.' + next_head

        return list(map(split_modules, available_modules))

    def do_task(self, args):
        try:
            sub_opt, arg = args.split(' ')[0].strip(), args.split(' ')[1:]
            if sub_opt not in self.sub_opt['task']:
                raise BadHostInfoException()
        except IndexError:
            utils.print_failed("Error during setting '{}'\n"
                               "Not enough arguments\n"
                               "Use <tab> key multiple times for completion.".format(args))
            return
        except BadHostInfoException as err:
            utils.print_failed("Error during setting '{}'\n"
                               "Use <tab> key multiple times for completion.".format(args))
            return
        try:
            self.task.__getattribute__(sub_opt)(arg)
        except BadHostInfoException as err:
            utils.print_failed("Error during setting '{}'\n"
                               "{}.\n"
                               "Please check the arguments input.".format(sub_opt, err))

    def complete_task(self, text, line, *args):
        if len(line.split(' ')) > 2:
            return [' '.join((attr, '')) for attr in self.files if attr.startswith(text)]
        else:
            return self.auto_complete(text, 'task')

    def do_show(self, arg):
        self.task.show()

    def do_check(self, arg):
        utils.print_info('checking if module loaded')
        if not self.check_module_loaded():
            utils.print_failed('checking module failed\n'
                               'Please make sure you have already choose one module')
            return

        utils.print_info('checking targets info')
        if not self.check_target_arg():
            utils.print_failed('checking targets info failed\n'
                               'Please make sure you input info target info')
            return
        else:
            utils.print_success('passing checking...')
        target = self.task.get_current()
        if self.module.check(target.host, target.port, self.task.get_timeout()):
            module_name = inspect.getmodule(self.module).__name__[16:]
            exploits = target.affective_exploit
            if not exploits:
                a_exploit = [module_name]
            else:
                if module_name not in exploits:
                    a_exploit = exploits.append(module_name)
                else:
                    a_exploit = exploits
            self.task.set_current(ExploitTarget(host=target.host, port=target.port, brand=target.brand,
                                                alternative_exploit=target.alternative_exploit,
                                                affective_exploit=a_exploit))

    def do_run(self, arg):
        utils.print_info('checking if module loaded')
        if not self.check_module_loaded():
            utils.print_failed('checking module failed\n'
                               'Please make sure you have already choose one module')
            return

        utils.print_info('checking targets info')
        if not self.check_target_arg():
            utils.print_failed('checking targets info failed\n'
                               'Please make sure you input info target info')
            return
        else:
            utils.print_success('passing checking...')
        target = self.task.get_current()
        self.module.run(target.host, target.port, self.task.get_timeout())

    def do_back(self, arg):
        return True

    def complete_show(self, text, *args):
        return self.auto_complete(text, 'show')

    def auto_complete(self, text, opt):
        if text:
            return [' '.join((attr, '')) for attr in self.sub_opt[opt] if attr.startswith(text)]
        else:
            return self.sub_opt[opt]

    def check_target_arg(self):
        if self.task.get_current():
            return True
        else:
            return False

    def check_module_loaded(self):
        if self.module:
            return True
        else:
            return False

